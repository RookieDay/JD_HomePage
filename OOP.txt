1.面向对象code
// 测试
			
			// 凡是函数就有属性 prototype 
			// 由某一个函数 new 出来的对象, 会自动的链接到 该函数的 prototype
			var Fn1 = function () {};
			var Fn2 = function () {};
			
			var f1 = new Fn1();	// 自动的链接到 Fn1.prototype
			var f2 = new Fn2(); // 自动链接到 Fn2.prototype
			
			// 测试
			var o1 = new Object(),	// o1 -> Object.prototype
				f = new Array(3),	// f -> Array.prototype
				d = new Date();		// d -> Date.prototype
			
			// 链接到 prototype 上有什么用?
			// 属性( 属性与方法 )
			var p = {
				name: 'jim',
				age: 19,
				sayHello: function() {}
			};
			// 如果访问对象的属性, 就在当前对象中找, 如果没有在其原型对象中找
			// 原型对象就是对象的构造函数的 prototype 属性
			
			// 原型对象与原型属性
			
			// __proto__ 与 prototype 有什么区别?
			// __proto__ 是站在对象的角度讨论其原型对象
			// prototype 是站在构造函数的角度讨论原型属性, 或构造函数创建的对象的原型对象
			
			// 提问
			// 1, 笔记
			// 2, 判断有限数字		isFinite()
			console.log( 10 / 0 ); // => 10 / x , x->0
			console.log( isFinite( 10 / 0 ) );
			
			// 判断是数字
			// 做数学运算
			var a = '123';
			var b = 'abc';
			
			console.log( a - 0 );
			console.log( b * 1 );
			// 判断数字是 NaN
			// iSNaN
			// 在 js 中有一个特性, NaN 与自己不相等  自己与自己不等就是NAN
			console.log( '123' == '123' ); // 引用类型 不能这么判断
			
			var ooo = {};
			var ooo2 = ooo;
			console.log( ooo === ooo2 );   true
			
			var nan = NaN;
			var nan2 = nan;
			console.log( nan == nan2 ); false
			
			console.log( NaN == NaN ) false
			
			
			// setTimeout 多少秒后执行 1 次
			// setInterval 多少秒后 执行, 间隔 该描述再次执行, 直到 clearInterval
			

2.			
var Student=function (name,age,sex,a,b,c) {
    this.name=name;
    this.age=age;
    this.sex=sex;
    this.lesson={chinese: a,math: b,english: c};
    this.sayhello=function () {
        console.log();
    }
}
var p=new Student("aaa",18,"boy",100,100,100);

var p3=new Student();
var p4=new Student();
console.log(p3.sayhello===p4.sayhello);
-------------------------

function fun(name) {
        this.name=name;
    }
    fun.prototype.sayhello=function () {

    }

    var p1=new fun("dsfs");
    var p2=new fun("dsfdfsd");
    console.log(p1.sayhello===p2.sayhello);

p3和p4不相等，p1和p2就相等		

3.
			// 对象的类型是什么
			// typeof 操作对象 统一返回的是 object	
			function Person () {}
			var p = new Person();		// 常常描述为 Person 对象
			
			// 创建 xxx 对象, 描述的是构造方法的名字
			// 构造函数的名字就是 对象的类型的 名字
			
						// 每一个对象都可以访问到一个属性
			// 其中有一个是 constructor ( 构造器 )
			// 每一个对象的 constructor 属性描述的是其构造函数
			
			function Fn() {}
			
			var o = new Fn();
			
			console.log( o.constructor === Fn ); 
			
			// 每一个对象都链接到 其 原型对象上 
			// 对象的 constructor 属性是其原型对象提供的
			
			var obj = {};
			
			console.log( obj.constructor );
			
			// 每一个对象都有原型对象
			
			
			// 如何获得对象的类型???
	// var Person = function () {};
			
			function Person () {}
			
			var p = new Person();
			
			// 1, 获得对象的构造函数
			var ctr = p.constructor;
			// 2, 将函数转换为字符串
			var s = "" + ctr;		// 'function Person () {}'
			// 3, 将 function 与 ( 之间的字符串截取出来
			// alert( s );
			
			// 3.1 传统的字符串处理函数
			/*
			var start = s.replace("function", "|").indexOf( '|' );
			if ( start != -1 ) {
				var end = s.replace("function", "|").indexOf('(');
				if ( end != -1 ) {
					var name = s.replace("function", "|").slice(start + 2, end);
					alert( "|" + name + "|" );
				}
			}
			*/
			// 找start 和 end
			// if (start != -1 && end != -1) ...
			
			// string <string>.replace( <string>, <string> )
			// number <string>.indexOf( <string> )
			// string <string>.slice( startIndex, endIndex )
			
			
			// 简化1, 将重复的字符串处理合并, 利用一个变量来描述
			// s = s.replace("function", "|");	// '| 名字() {}'
			// 简化2, if 嵌套 if 代码很复杂
			/*
			var start = s.indexOf( '|' );
			if ( start != -1 ) {
				var end = s.indexOf('(');
				if ( end != -1 ) {
					var name = s.slice(start + 2, end);
					alert( "|" + name + "|" );
				}
			}*/
			
			// 获得开始的索引, 获得结束的索引, 如果索引符合要求, 就获得字符串
			/*
			var start = s.indexOf( '|' );
			var end = s.indexOf('(');
			if ( start != -1 && end != -1 ) {
				var name = s.slice(start + 2, end);
				alert( "|" + name + "|" );				
			}*/
			
			
			// 3.2 利用正则表达式
			// 'function Person () {}'
			/*
			var r = /function (.+)\(/;
			var name = r.exec( s )[ 1 ];
			alert( "|" + name + "|" );
			*/
		
			// 3.3 函数有一个属性, 叫 name 该属性表示函数的名字
			alert ( ctr.name );	// IE 8 不支持

通用的获得对象的类型
			
			// 写一个函数, 获得函数名
			/*
			function getFnName( fn ) {				
				// 验证传入的一定是函数
				if ( typeof ( fn ) !== 'function' ) return;
				
				// 保证是函数
				if ( fn.name ) {
					return fn.name;
				} else {
					return /function (.+)\(/.exec( fn + '' )[ 1 ];
				}				
			}
			*/
			
			简化书写
			function getFnName( fn ) {				
				// 验证传入的一定是函数
				if ( typeof ( fn ) !== 'function' ) return;
				/*
				return fn.name ? 
						fn.name :
						/function (.+)\(/.exec( fn + '' )[ 1 ];
				*/
				return fn.name ||
						/function (.+)\(/.exec( fn + '' )[ 1 ];   (如果前面为真 就返回前面的  否则继续执行 返回后面的)
			}
			
			// 逻辑中断
			//	||
			//	&&
			
			继续简化：
			function getFnName( fn ) {				
			
				return 	typeof ( fn ) !== 'function' ？
						undefined:
						fn.name ||
						/function (.+)\(/.exec( fn + '' )[ 1 ];   (如果前面为真 就返回前面的  否则继续执行 返回后面的)
			}
			
			function PersonChen1234567890() {}
			var o = new PersonChen1234567890();
			
			var name = getFnName( o.constructor );
			
			alert( name );
测试如上方法：
			// 不做要求
			function getFnName( fn ) {								
						
				return typeof fn !== 'function' ?
							undefined:
							fn.name ||
							/function (.+)\(/.exec( fn + '' )[ 1 ]
							
			}
			
			function nameDaStudent() {}
			var o = new nameDaStudent();
			
			var name = getFnName( o.constructor );

			alert( name );
					var name1 = getFnName( nameDaStudent );
			alert(name1);
		</script>
		
面向对象特性：
// 面向对象的特征就是 封装性, 继承性 和 多态性
			// 封装: 就是将复杂包裹, 隐藏起来, 让简单的东西预留在外面
			// 继承: 拿来主义, 自己没有, 把别人的拿过来, 让其成为自己的
			
			// 在 js 中有两种继承模型
			// 1, 原型继承
			// 2, 组合继承
			
			// 1, 原型继承
			// 如果需要让一个对象有某一个行为( 属性, 方法 ), 那么可以考虑将这个行为
			//	加到原型对象中, 那么这个对象就继承自原型对象, 获得了该行为
			
			// 2, 组合式继承
			// 组合式继承将其他的对象中的成员加到自己身上
			var o1 = { name: 'jim', age:19, gender: '男' };
			var o2 = { score: {
				math: 100,
				english:90,
				chinese:120
			} };
			// 让 o2 继承自 o1
			// 将 o1 的成员加到 o2 上  我们可以o2上加很多类似的
//			for ( var k in o1 ) {
//				o2[ k ] = o1[ k ];
//			}
			
			// 由于 for in 循环中的对象可以随意的替代, 因此 o2 可以继承自任意的对象
			// 因此, 这个继承方法称为组合式继承
			// 这里希望 o2 可以继承自任意的对象. 所以为了简化继承的代码
			// 给 o2 提供一个方法, 叫 extend
			o2.extend = function ( obj ) {
				for ( var k in obj ) {
					this[ k ] = obj[ k ];
				}	
			}
			
			o2.extend( o1 );  // 继承
			
			o2.extend({ 		自己加入新的对象
				id: function( id ) {
					
				},
				tag: function ( tag ) {
					
				},
				showErr: function (msg) {
					throw new Error( msg );
				}
			});		
			
原型继承
// 什么是原型式继承
			// 对象继承自其原型对象
			
			// 所谓的原型式继承就是在 对象的 原型对象中加东西即可
			// 如何使用原型对象
			// 1, 利用对象的动态特性添加成员
			/*
			var o = {};
			o.name = 'jim';
			
			var Person = function () {};
			Person.prototype.sayHello = function () {
				alert (' 哈哈哈 ');
			};
			*/
			// 此时 原型对象是对象, 可以利用动态特性随时添加成员
			// 添加的成员都会被 构造函数创建的对象所继承
			
			当然对象找不到的时候会到原型对象里面去找
			
			// 2, 利用覆盖原型对象
//			var Person = function () {};
//			Person.prototype.sayHello = function () {
//				alert (' 哈哈哈 ');
//			};
//			Person.prototype.sayGoodbye= function () {};
//			Person.prototype.sayLove = function () {};
			// ...
			
			// 如果需要添加的内容非常多
			// var Person = function () {};
			function Person() {}   凡是有了函数 默认就有prototype  默认的prototype 它里面有constructor属性 指的就是构造函数
			
			Person.prototype = {			原来的prototype被当前的替换了
				constructor: Person,   **************** 加上这句话后				
				sayHello: function() {},
				sayGoodbye: function() {},
				sayLove: function () {}
				
			};
			// 这里由 Person 创建出来的对象什么类型?
			// Object
			// 为什么? 合理吗?
			var p = new Person();    
			
			console.log( p.constructor.name );  --> 出来的是Object 加上上面那句话  就是Peroson
			p里面没有 就去原型对象里面找  原型里面没有，被替换了 去原型对象的原型对象去寻找 是Object  
			
			// 覆盖原型对象实现继承的时候, 一定要给新对象添加一个 constructor 属性
			// 以便模拟对象的类型. 但是如果对对象的类型要求不严格可以忽略
			
			// 3, 利用组合式继承添加原型成员
			// 对象.extend( 对象 )

经典做法：
	// 在实际开发中, 如果希望获得一个继承自 对象 o 的对象
			// 可以使用 Object.create 方法
			// ES5 提供的方法
			
			// 新对象 Object.create( 作为原型对象的对象 )
			
			var o1 = { name: 'jim' };
			// var o2 = Object.create( o1 );
			// 类型无关
			
			// 明确函数调用语法
			// 功能是什么?
			
			
			// 它会创建一个新对象, 让他继承自参数 对象
			// 创建新对象就有构造函数
			// 继承对象就有原型对象
			
			
//			function create( obj ) {
//				function F() {}
//				// 要有继承
//				F.prototype = obj;  
//				return new F();
//			}
//			var o3 = create( o1 );
			
			
			// 在实际开发中, 如果是为了兼容所有的浏览器, 有两种做法
			// 1, 在原生对象中提供方法   主要兼容IE
			if ( !Object.create ) {
				Object.create = function ( obj ) {			会造成对原生对象的污染  
					function F() {}
					// 要有继承
					F.prototype = obj;     F new出来的对象 通通继承自obj
					return new F();
				}
			}
			
			var o4 = Object.create( o1 );
			
			var _ = 0;                    这一行主要是为了方便调试 可以断电设在这里
			// 2, 统一用新的方法
			var create = function( obj ) {
				if ( Object.create ) {
					return Object.create( obj );
				} else {
					
					function F() {}
					F.prototype = obj;
					return new F();
				}
			}
			
			
			var o5 = create ( obj );
			// 无论浏览器是否支持该方法, 都应该使用自己定义的方法来完成, 但是
			// 在方法内部, 判断浏览器是否具有该功能, 如果有该功能
			// 则使用浏览器提供 的功能
			// 如果浏览器不支持该功能, 则自己实现
			
// 原型式继承
			// 1, 概念: 对象继承自原型对象: 对象没有的成员, 可以由原型对象提供
			// 2, 实现方式
			//		-> 动态添加原型对象的成员
			//		-> 直接替换原型对象( 如果对类型要求严格需要添加 constructor 属性 )
			//		-> 利用 extend 函数给原型对象添加成员
			
			// 经典的继承代码
			var o1 = { name: 'tom' };
			var o2 = Object.create( o1 );
			
			// o2 作为对象, 他的原型对象由谁决定
			// o2 的原型对象由构造函数的 prototype 决定
			// o2 的原型对象是 o1
			// 结论
			// o2 的构造函数的 prototype = o1
			
			// o2 有构造函数吗?
			// o2 是由 create 函数创建, 那么在函数内部有一个构造函数就可以了
			var create = function ( obj ) {
				function F() {}
				F.prototype = obj;
				return new F();
			}
			
			
			// 浏览器兼容性的问题
			// 1, 直接交给原生对象, 给原生对象提供功能
			if ( !Object.create ) {
				Object.create = function ( obj ) {
					function F() {}
					F.prototype = obj;
					return new F();
				}
			}
			
			// 2, 无论是什么浏览器, 都执行通用的方法.
			// 在方法中判断是否使用原生方法
			function create( obj ) {
				if ( Object.create ) {
					// 判断浏览器是否支持
					return Object.create( obj );
				} else {
					function F() {}
					F.prototype = obj;
					return new F();
				}
			}			
原型链继承
			var o = new Object();
			// toString
			// constructor
			// ...
			
			// 对象是有原型对象
			// 
			function Fn() {}
			var o = new Fn();
			
			// 原型对象也有原型对象, 对象的原型对象一直往上找, 会找到一个 null
			// 在这个过程中, 有一个 Object 类型的, 有很多方法的对象
			// 它就是 Object.prototype
			
			
			// 要求 看到一个对象就知道他的原型链是什么样子的
			
			var arr = [];
			arr -> Array.prototype -> Object.prototype -> null
			
			var o = new Object();
			o -> Object.prototype -> null
			
// 一个基本类型, 在内存中的逻辑结构
			var num = 123;
			// 在 内存中有一个区域 存储者数字 123, 这个内存标记为 num
			// 
			// 如果内存中存储 一个 字符串 "abc"
			
			// 值类型存储数值本身
			var str = 'abc'
			
			// boolean
			var isTrue = true;
			
			
			// 例如引用类型
			var o = { num: 123 };
			// 引用类型存储的是数据的引用
			// 引用类型的数据, 有两个存储区域, 一个存储数据本身, 一个变量存储引用
			
			
			
			// 数组
			var arr = [ 1, 2, 3, 4, { num: 123 } ];
			// 数组是引用类型
			var arr1 = [ 1, 2, 3 ];
			
			
			// 练习
//			var o = {
//				num: 123,
//				name: 'jim',
//				scores: {
//					'math': 100,
//					'english': 1,
//					'chinese': 99
//				},
//				father: [ '干爹1', '干爹2', ...]
//			}
			
			
			


















			
			
			